# My ePortfolio
_A review of my time in SNHU's Computer Science program, a review of past projects, and enhancements made to those projects._
---

## My Self-Assessment

&nbsp;My time in the computer science program at SNHU has helped me to develop and showcase my technical strengths while shaping my professional goals and values. My journey with SNHU has helped me to hone my skills while encouraging an appetite for constant learning and growth. Working on code reviews and artifact enhancements, and the necessary reflection that comes with these tasks, has taught me the importance of clean, industry-standard code, adapting to feedback, and constantly striving for improvement. By reflecting on past work, I can see both how I’ve grown into an asset for potential employers and how I can continue to grow and improve.
&nbsp;Importantly, my courses emphasized teamwork and communication. I’ve gained experience collaborating in a team environment while communicating clearly and respectfully by participating in group projects and discussions. CS-250: Software Development Lifecycle gave me valuable experience with agile roles and communication with members of my team, stakeholders, and product owners. This course also focused on requirement elicitation, which taught me the importance of documentation, responsive communication, and creative problem solving. The ability to demonstrate project progress to both technical and non-technical audiences is another crucial skill that contributes to my ability to communicate clearly with diverse audiences and carefully consider other perspectives.
&nbsp;My studies have also given me solid foundations in data structures and algorithms. In courses like CS-300: Data Structures and Algorithms: Analysis and Design I was introduced to linked lists, hash tables, binary search trees, sorting algorithms, and more. Becoming familiar with these data structures and algorithms was key to understanding the importance of data organization and efficiency in software. These projects sharpened my algorithmic problem-solving skills, and this ePortfolio includes artifacts that demonstrate those techniques.
&nbsp;Collectively, the artifacts and documentation in this portfolio demonstrate achievement of the program’s core outcomes. Through projects that required iterative development, code review, and enhancement, I employed strategies for building collaborative environments that support organizational decision making, reflecting real-world team dynamics and stakeholder input. The portfolio itself, through clear documentation and structured narratives, illustrates my ability to design, develop, and deliver professional-quality communications that are technically sound and tailored to a diverse audience. Each artifact showcases my capacity to design and evaluate computing solutions using established algorithmic principles and computer science standards, while managing trade-offs related to performance, scalability, maintainability, and usability. Additionally, the projects highlight my use of well-founded and innovative tools, techniques, and development practices to implement solutions that deliver measurable value and align with industry expectations. Finally, considerations with each enhancement demonstrate a security-first mindset that anticipates potential exploits and identifies vulnerabilities in software design while applying mitigation strategies to protect data and system integrity. This portfolio presents a cohesive body of work that reflects my readiness to contribute as thoughtful, adaptable, and security-conscious computer science professional.


---

## My Code Review
[![Code Review](http://img.youtube.com/vi/8BtHXfK6Qr4/0.jpg)](http://www.youtube.com/watch?v=8BtHXfK6Qr4 "Code Review")

An informal code review of artifacts developed during my time in the SNHU Computer Science program. 

---

## Artifacts
### Below are the artifacts hosted in this repository and their corresponding narratives.
---

**Pet BAG:** A pet boarding and grooming program with persistent pet data.

[Browse project files](https://github.com/C-Glee/c-glee.github.io/tree/main/projects/artifact_1)

  This artifact is the *Pet Boarding And Grooming (Pet BAG)* application from IT-145: Foundations in Application Development. It was originally created in June of 2024 and was an introductory assignment to algorithmic logic and Java. The original assignment involved creating a Pet.java class and pseudocode for the check-in method of a hypothetical Pet BAG application. This artifact was selected for enhancement due to both it being created a year ago and because of the barebones implementation. The enhancement showcases the ability to improve on algorithmic logic and write readable, modular, and maintainable code. By reviewing the initial draft of the *Pet.java* class file and the pseudocode for the check-in method, I was able to carefully consider what the requirements of a functioning Pet BAG progrma would look like and what would need to be reworked or implemented to achieve them. This meant considering what variables, data structures, and classes were necessary for the pgroam, what the main loop of the program would be, and the methods required to bring the desired functionality to the new version of Pet BAG. This enhancements demonstrates both a growth in my understanding of algorithmic logic and coding capabilities as well as my ability to take an incomplete design for a project and extrapolate the requirements for it while developing the prototype into a fully-fledged application. The enhanced artifact stores pet data persistently and allows the user to check in, update information, check out, or view currently boarded pets through the console. Any changes made are saved to a pets.txt which is loaded on application start.
  Enhancing this artifact was more like refactoring it from the ground up. The Pet.java class was a decent jumping off point, but the pseudocode required a lot of logical overhauls. After reviewing the Pet.java class and adding the variables that were missing, as well as corresponding setters and getters, I also added a simple toString method that I planned to use later. Creating the main body of the Pet BAG program began with a simple consideration of the requirements and how they could be delivered. This began with the main menu loop and from there the methods for checking in a pet, viewing pets, and checking out a pet were added one by one. Afterward, I figured that the ability to update a pet through the check-in method was an addition that made sense even if it was not in the original enhancement plan. Determining how to handle this turned out to be the biggest challenge. Originally, I struggled determining how to best handle returning customers and implemented a returning customer branch that I felt was lackluster. This involved two separate check in methods, one that determined if the user was a repeat customer and then sent either a specific Pet (located by ID) to the true check-in function or a new (blank) Pet. This was reworked and ultimately removed in favor of a single check in method which prompts the user if they are updating a pet and, if not, proceeds with normal check in. The last methods added were those which managed the Pet data and handled reading and writing the pet data to an external file. After these were added to the program and tested to ensure they functioned correctly, I determined it would be best to move the date handling to its own module. Thus the PetDataManager.java class was created and the method to read the Pet data from a file was made more robust so that it can handle malformed or improperly formatted lines (and log the lines that encountered errors). Now that the enhancement is complete, I can clearly see the difference between the original artifact and how both it and I have developed. The enhancement allowed me to demonstrate the skills, technique, and knowledge I’ve accrued while giving me the chance to continue to learn and improve. This enhancement required research into string formatting to achieve both more readable code and well-formatted outputs for the user.

---

**ABCU Advising:** A program which loads and displays course data while benchmarking performance of multiple data structures.

[Browse project files](https://github.com/C-Glee/c-glee.github.io/tree/main/projects/artifact_2)

  This artifact is the ABCU Advising application from CS-300: Data Structures and Algorithms: Analysis and Design. This application is written in C++ and was originally created in May of 2025. The original artifact was an ABCU Advising.cpp file which contained code to parse data from a CSV file, load that data into a Binary Search Tree, list all courses, and search for a specific course. This artifact was seleccted for my portfolio to showcase skils related to the implementation of data structures and the relevant algorithms for each. Custom class implementations of these structures, *CourseTree*, *CourseHashTable*, and *CourseLinkedList*, were used to demonstrate an understanding of each structure. The implementation of CourseTable’s insertion, destruction, and traversal methods demonstrate an understanding of recursive algorithms, dynamic memory allocation, and sorted data retrieval. The implementation of CourseHashTable demonstrates an understanding of hash functions, bucket arrays, and collision handling via vectors. The implementation of CourseLinkedList demonstrates understanding in pointer manipulation, node chaining, appending nodes, and sequential search. The side-by-side implementation and comparison of these structures demonstrates both an understanding of the structures themselves and the algorithms which are required to construct, destruct, and traverse them. Lastly, a centralStorage vector was used to hold a canonical list of data, while pointers to this data are held in each of the data structures to preserve data integrity and avoid duplicated memory despite the use of several data structures to handle the same data.
  The enhanced artifact is both more robust and technically advanced compared to its original iteration. The program has been re-designed to be signficantly more modular, more readable, parse CSVs in a more robust manner, handle several parallel data structures, and benchmark performance. The original single-file C++ application has been split into several modules which separately handle CSV parsing, the data structures (binary search tree, linked list, hash table, and course), and the main loop of the program. This greatly improves the original artifact's readability, maintainbility, and reuseability. Rather than just a BinarySearchTree, the enhanced artifact makes use of a vector for central storage as well as a binary search tree, linked list, and hash table for storing the list of courses. These structures have their traversal and search performance benchmarked, a completely new addition to the program. Both the full-traversal and search performance of each structure are measured in nanoseconds across thousands of iterations. Afterward, the average for each is calculated and the fastest data structure is highlighted for the user.
  The enhancements of this artifact were successful in meeting the intended course outcomes. The intended outcomes were two, three, and four. Outcome two is designing, developing, and delivering professional quality oral, written, and visual communications. Outcome three is designing and evaluating computing solutions that solve a problem using algorithmic principles and computer science practices/standards appropriate to the solution while weighing trade-offs involved in design choices. Outcome four is demonstrating an ability to use well-founded and innovative techniques, skills and tools in computing practices to implement computer solutions which deliver value and accomplish goals. All three of these outcomes are met by the enhancements of this artifact. Additionally, this artifact demosntrates outcome five, develop a security mindset that anticipates exploits, exposes vulnerabilities, and mitigates design flaws. The enhanced artifact parses data in a robust and safe way while handling erroneous inputs in a way that avoids crashes or errors and maintains expected behavior. Outcome one, strategies for building collaborative environments that enable diverse audiences to support organizational decision-making, is also met by this enhancement. While this is an outcome that is largely met through professional and respectful behavior, a large part of a collaboration when it comes to developing software lies in documentation and the code itself. The code is more thoroughly commented, and the project has been refactored to become more readable and maintainable. All of these elements foster collaboration among multiple developers. 
  
---

**ContactService:** A contact service application which loads contacts from an embedded database and allows CRUD operations via a GUI.

[Browse project files](https://github.com/C-Glee/c-glee.github.io/tree/main/projects/artifact_3)

  This artifact is the *ContactService* application from CS-320: Software Testing, Automation, and Quality Assurance and it was created in November of 2024. The original artifact was an exercise in creating JUnit tests. It consisted of two classes, *Contact* and *ContactService*, and a corresponding JUnit test for each of these classes. The original artifact does not offer any user interaction and its functionality is verified purely through its tests. This item was selected for a few reasons. The first reason is that I wanted to take a bare-bones project and flesh it out from a couple of non-interactive class files into an application which allows for a user to perform contact management. Taking a previous application from a very early phase and developing it into a full application helps to demonstrate the growth of my software design skills and understanding of algorithmic logic. The last reason was that *ContactService* is an app that necessitates a database and, before this enhancement, I had no experience with embedded databases. 
    The initial enhancements for this artifact include methods which allows a user to perform CRUD operations on contacts, a GUI which enables the user’s interaction with the application, and an embedded database which persistently stores contact information. The enhancements demonstrate capability with designing and implementing a GUI using JavaFX, as well as designing a database schema and implementing an embedded database using SQLite. This process required research into methods for implementation of GUIs and embedded databases, weighing potential designs of both the GUI and database, and integrating that implementation into the design and logic of the application.
    As creating a GUI and embedded database for a Java-based application were both relatively unfamiliar to me, the first step of the enhancement was creating a plan. I knew what I wanted to achieve and the next step was determining how to achieve it and weighing my options. The first challenge was determining which toolkit I wanted to use for my GUI. It came down to either JavaFX or Swing, and I settled on JavaFX since my research indicated it was more modern and actively being developed while Swing is established but generally used for legacy applications. After deciding to use JavaFX, the next step was to determine whether I was going to use SQLite or H2 for the embedded database. SQLite appeared to be widely used, robust, and resilient to corruption. The idea of H2’s pure java implementation was tempting, but after stumbling on other developers attempting to troubleshoot their H2 database corruption I decided to commit to SQLite. JavaFX and SQLite were both new to me, which presented a challenge in and of itself, but my experience with designing and implementing databases and UIs in the past made them both surprisingly intuitive. With the final enhancements completed, *ContactService* now allows for CRUD operations on its embedded Contact database through a fully interactive GUI.
  The enhancements of this artifact successfully met all the intended course outcomes. The original intended outcomes were three, four, and five. The research related to the enhancement and the implementation of the enhancement demonstrates the capability of designing and evaluating computing solutions that solve a given problem using computer science practices and standards, as well as well-founded techniques, skills, and tools while weighing potential trade-offs. A security-oriented mindset is demonstrated both through comprehensive tests and through input validation of contact information.
  
---

_Last updated: 12/14/2025_
